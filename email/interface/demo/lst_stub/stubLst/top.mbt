// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!

pub(all) type FutureAddResult Int derive(Show)

/// Drops a resource handle.
pub fn FutureAddResult::drop(self : FutureAddResult) -> Unit {
      let FutureAddResult(resource) = self
      wasmImportResourceDropFutureAddResult(resource)
}

pub(all) type FutureConnectResult Int derive(Show)

/// Drops a resource handle.
pub fn FutureConnectResult::drop(self : FutureConnectResult) -> Unit {
      let FutureConnectResult(resource) = self
      wasmImportResourceDropFutureConnectResult(resource)
}

pub(all) type FutureConnectedEditorsResult Int derive(Show)

/// Drops a resource handle.
pub fn FutureConnectedEditorsResult::drop(self : FutureConnectedEditorsResult) -> Unit {
      let FutureConnectedEditorsResult(resource) = self
      wasmImportResourceDropFutureConnectedEditorsResult(resource)
}

pub(all) type FutureDeleteResult Int derive(Show)

/// Drops a resource handle.
pub fn FutureDeleteResult::drop(self : FutureDeleteResult) -> Unit {
      let FutureDeleteResult(resource) = self
      wasmImportResourceDropFutureDeleteResult(resource)
}

pub(all) type FutureDisconnectResult Int derive(Show)

/// Drops a resource handle.
pub fn FutureDisconnectResult::drop(self : FutureDisconnectResult) -> Unit {
      let FutureDisconnectResult(resource) = self
      wasmImportResourceDropFutureDisconnectResult(resource)
}

pub(all) type FutureGetResult Int derive(Show)

/// Drops a resource handle.
pub fn FutureGetResult::drop(self : FutureGetResult) -> Unit {
      let FutureGetResult(resource) = self
      wasmImportResourceDropFutureGetResult(resource)
}

pub(all) type FutureInsertResult Int derive(Show)

/// Drops a resource handle.
pub fn FutureInsertResult::drop(self : FutureInsertResult) -> Unit {
      let FutureInsertResult(resource) = self
      wasmImportResourceDropFutureInsertResult(resource)
}

pub(all) type FutureIsArchivedResult Int derive(Show)

/// Drops a resource handle.
pub fn FutureIsArchivedResult::drop(self : FutureIsArchivedResult) -> Unit {
      let FutureIsArchivedResult(resource) = self
      wasmImportResourceDropFutureIsArchivedResult(resource)
}

pub(all) type FuturePollResult Int derive(Show)

/// Drops a resource handle.
pub fn FuturePollResult::drop(self : FuturePollResult) -> Unit {
      let FuturePollResult(resource) = self
      wasmImportResourceDropFuturePollResult(resource)
}

pub(all) type FutureDeadlineResult Int derive(Show)

/// Drops a resource handle.
pub fn FutureDeadlineResult::drop(self : FutureDeadlineResult) -> Unit {
      let FutureDeadlineResult(resource) = self
      wasmImportResourceDropFutureDeadlineResult(resource)
}

pub(all) type FutureRecipientsResult Int derive(Show)

/// Drops a resource handle.
pub fn FutureRecipientsResult::drop(self : FutureRecipientsResult) -> Unit {
      let FutureRecipientsResult(resource) = self
      wasmImportResourceDropFutureRecipientsResult(resource)
}

pub(all) type Api Int derive(Show)

/// Drops a resource handle.
pub fn Api::drop(self : Api) -> Unit {
      let Api(resource) = self
      wasmImportResourceDropApi(resource)
}

pub(all) type EmailQuery Int derive(Show)

/// Drops a resource handle.
pub fn EmailQuery::drop(self : EmailQuery) -> Unit {
      let EmailQuery(resource) = self
      wasmImportResourceDropEmailQuery(resource)
}

pub fn FutureAddResult::subscribe(self : FutureAddResult) -> @poll.Pollable {

      let FutureAddResult(handle) = self
      let result : Int =  wasmImportMethodFutureAddResultSubscribe(handle);
      return @poll.Pollable::Pollable(result)

}

pub fn FutureAddResult::get(self : FutureAddResult) -> Result[Unit, String]? {

      let FutureAddResult(handle) = self
      let return_area = @ffi.malloc(16)
      wasmImportMethodFutureAddResultGet(handle, return_area);

      let lifted6 : Result[Unit, String]? = match @ffi.load8_u((return_area) + 0) {
            0 => Option::None
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              Result::Ok(())
                        }
                        1 => {

                              ignore(@ffi.load32((return_area) + 12))
                              let result = @ffi.ptr2str(@ffi.load32((return_area) + 8))

                              Result::Err(result)
                        }
                        _ => panic()
                  }

                  Option::Some(lifted)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}

pub fn FutureConnectResult::subscribe(self : FutureConnectResult) -> @poll.Pollable {

      let FutureConnectResult(handle) = self
      let result : Int =  wasmImportMethodFutureConnectResultSubscribe(handle);
      return @poll.Pollable::Pollable(result)

}

pub fn FutureConnectResult::get(self : FutureConnectResult) -> (@api.Connection, Array[String])? {

      let FutureConnectResult(handle) = self
      let return_area = @ffi.malloc(24)
      wasmImportMethodFutureConnectResultGet(handle, return_area);

      let lifted : (@api.Connection, Array[String])? = match @ffi.load8_u((return_area) + 0) {
            0 => Option::None
            1 => {

                  let array : Array[String] = [];
                  for index = 0; index < (@ffi.load32((return_area) + 20)); index = index + 1 {
                        let base3 = (@ffi.load32((return_area) + 16)) + (index * 8)

                        ignore(@ffi.load32((base3) + 4))
                        let result = @ffi.ptr2str(@ffi.load32((base3) + 0))

                        array.push(result)
                  }
                  @ffi.free(@ffi.load32((return_area) + 16))

                  Option::Some((@api.Connection::{id : (@ffi.load64((return_area) + 8)).reinterpret_as_uint64()}, array))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn FutureConnectedEditorsResult::subscribe(self : FutureConnectedEditorsResult) -> @poll.Pollable {

      let FutureConnectedEditorsResult(handle) = self
      let result : Int =  wasmImportMethodFutureConnectedEditorsResultSubscribe(handle);
      return @poll.Pollable::Pollable(result)

}

pub fn FutureConnectedEditorsResult::get(self : FutureConnectedEditorsResult) -> Array[String]? {

      let FutureConnectedEditorsResult(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodFutureConnectedEditorsResultGet(handle, return_area);

      let lifted : Array[String]? = match @ffi.load8_u((return_area) + 0) {
            0 => Option::None
            1 => {

                  let array : Array[String] = [];
                  for index = 0; index < (@ffi.load32((return_area) + 8)); index = index + 1 {
                        let base3 = (@ffi.load32((return_area) + 4)) + (index * 8)

                        ignore(@ffi.load32((base3) + 4))
                        let result = @ffi.ptr2str(@ffi.load32((base3) + 0))

                        array.push(result)
                  }
                  @ffi.free(@ffi.load32((return_area) + 4))

                  Option::Some(array)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn FutureDeleteResult::subscribe(self : FutureDeleteResult) -> @poll.Pollable {

      let FutureDeleteResult(handle) = self
      let result : Int =  wasmImportMethodFutureDeleteResultSubscribe(handle);
      return @poll.Pollable::Pollable(result)

}

pub fn FutureDeleteResult::get(self : FutureDeleteResult) -> Result[Unit, String]? {

      let FutureDeleteResult(handle) = self
      let return_area = @ffi.malloc(16)
      wasmImportMethodFutureDeleteResultGet(handle, return_area);

      let lifted6 : Result[Unit, String]? = match @ffi.load8_u((return_area) + 0) {
            0 => Option::None
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              Result::Ok(())
                        }
                        1 => {

                              ignore(@ffi.load32((return_area) + 12))
                              let result = @ffi.ptr2str(@ffi.load32((return_area) + 8))

                              Result::Err(result)
                        }
                        _ => panic()
                  }

                  Option::Some(lifted)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}

pub fn FutureDisconnectResult::subscribe(self : FutureDisconnectResult) -> @poll.Pollable {

      let FutureDisconnectResult(handle) = self
      let result : Int =  wasmImportMethodFutureDisconnectResultSubscribe(handle);
      return @poll.Pollable::Pollable(result)

}

pub fn FutureDisconnectResult::get(self : FutureDisconnectResult) -> Result[Unit, String]? {

      let FutureDisconnectResult(handle) = self
      let return_area = @ffi.malloc(16)
      wasmImportMethodFutureDisconnectResultGet(handle, return_area);

      let lifted6 : Result[Unit, String]? = match @ffi.load8_u((return_area) + 0) {
            0 => Option::None
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              Result::Ok(())
                        }
                        1 => {

                              ignore(@ffi.load32((return_area) + 12))
                              let result = @ffi.ptr2str(@ffi.load32((return_area) + 8))

                              Result::Err(result)
                        }
                        _ => panic()
                  }

                  Option::Some(lifted)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}

pub fn FutureGetResult::subscribe(self : FutureGetResult) -> @poll.Pollable {

      let FutureGetResult(handle) = self
      let result : Int =  wasmImportMethodFutureGetResultSubscribe(handle);
      return @poll.Pollable::Pollable(result)

}

pub fn FutureGetResult::get(self : FutureGetResult) -> Array[String]? {

      let FutureGetResult(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodFutureGetResultGet(handle, return_area);

      let lifted : Array[String]? = match @ffi.load8_u((return_area) + 0) {
            0 => Option::None
            1 => {

                  let array : Array[String] = [];
                  for index = 0; index < (@ffi.load32((return_area) + 8)); index = index + 1 {
                        let base3 = (@ffi.load32((return_area) + 4)) + (index * 8)

                        ignore(@ffi.load32((base3) + 4))
                        let result = @ffi.ptr2str(@ffi.load32((base3) + 0))

                        array.push(result)
                  }
                  @ffi.free(@ffi.load32((return_area) + 4))

                  Option::Some(array)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn FutureInsertResult::subscribe(self : FutureInsertResult) -> @poll.Pollable {

      let FutureInsertResult(handle) = self
      let result : Int =  wasmImportMethodFutureInsertResultSubscribe(handle);
      return @poll.Pollable::Pollable(result)

}

pub fn FutureInsertResult::get(self : FutureInsertResult) -> Result[Unit, String]? {

      let FutureInsertResult(handle) = self
      let return_area = @ffi.malloc(16)
      wasmImportMethodFutureInsertResultGet(handle, return_area);

      let lifted6 : Result[Unit, String]? = match @ffi.load8_u((return_area) + 0) {
            0 => Option::None
            1 => {

                  let lifted = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              Result::Ok(())
                        }
                        1 => {

                              ignore(@ffi.load32((return_area) + 12))
                              let result = @ffi.ptr2str(@ffi.load32((return_area) + 8))

                              Result::Err(result)
                        }
                        _ => panic()
                  }

                  Option::Some(lifted)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}

pub fn FutureIsArchivedResult::subscribe(self : FutureIsArchivedResult) -> @poll.Pollable {

      let FutureIsArchivedResult(handle) = self
      let result : Int =  wasmImportMethodFutureIsArchivedResultSubscribe(handle);
      return @poll.Pollable::Pollable(result)

}

pub fn FutureIsArchivedResult::get(self : FutureIsArchivedResult) -> Bool? {

      let FutureIsArchivedResult(handle) = self
      let return_area = @ffi.malloc(2)
      wasmImportMethodFutureIsArchivedResultGet(handle, return_area);

      let lifted : Bool? = match @ffi.load8_u((return_area) + 0) {
            0 => Option::None
            1 => {

                  Option::Some((@ffi.load8_u((return_area) + 1) != 0))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn FuturePollResult::subscribe(self : FuturePollResult) -> @poll.Pollable {

      let FuturePollResult(handle) = self
      let result : Int =  wasmImportMethodFuturePollResultSubscribe(handle);
      return @poll.Pollable::Pollable(result)

}

pub fn FuturePollResult::get(self : FuturePollResult) -> Result[Array[@api.Change], String]? {

      let FuturePollResult(handle) = self
      let return_area = @ffi.malloc(16)
      wasmImportMethodFuturePollResultGet(handle, return_area);

      let lifted19 : Result[Array[@api.Change], String]? = match @ffi.load8_u((return_area) + 0) {
            0 => Option::None
            1 => {

                  let lifted18 = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              let array : Array[@api.Change] = [];
                              for index = 0; index < (@ffi.load32((return_area) + 12)); index = index + 1 {
                                    let base5 = (@ffi.load32((return_area) + 8)) + (index * 20)

                                    let lifted = match (@ffi.load8_u((base5) + 0)) {
                                          0 => {

                                                ignore(@ffi.load32((base5) + 8))
                                                let result = @ffi.ptr2str(@ffi.load32((base5) + 4))

                                                @api.Change::Added(result)
                                          }
                                          1 => {

                                                ignore(@ffi.load32((base5) + 8))
                                                let result10 = @ffi.ptr2str(@ffi.load32((base5) + 4))

                                                @api.Change::Deleted(result10)
                                          }
                                          2 => {

                                                ignore(@ffi.load32((base5) + 8))
                                                let result13 = @ffi.ptr2str(@ffi.load32((base5) + 4))

                                                ignore(@ffi.load32((base5) + 16))
                                                let result14 = @ffi.ptr2str(@ffi.load32((base5) + 12))

                                                @api.Change::Inserted(@api.InsertParams::{after : result13, value : result14})
                                          }
                                          _ => panic()
                                    }

                                    array.push(lifted)
                              }
                              @ffi.free(@ffi.load32((return_area) + 8))

                              Result::Ok(array)
                        }
                        1 => {

                              ignore(@ffi.load32((return_area) + 12))
                              let result17 = @ffi.ptr2str(@ffi.load32((return_area) + 8))

                              Result::Err(result17)
                        }
                        _ => panic()
                  }

                  Option::Some(lifted18)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted19

}

pub fn FutureDeadlineResult::subscribe(self : FutureDeadlineResult) -> @poll.Pollable {

      let FutureDeadlineResult(handle) = self
      let result : Int =  wasmImportMethodFutureDeadlineResultSubscribe(handle);
      return @poll.Pollable::Pollable(result)

}

pub fn FutureDeadlineResult::get(self : FutureDeadlineResult) -> UInt64?? {

      let FutureDeadlineResult(handle) = self
      let return_area = @ffi.malloc(24)
      wasmImportMethodFutureDeadlineResultGet(handle, return_area);

      let lifted6 : UInt64?? = match @ffi.load8_u((return_area) + 0) {
            0 => Option::None
            1 => {

                  let lifted : UInt64? = match @ffi.load8_u((return_area) + 8) {
                        0 => Option::None
                        1 => {

                              Option::Some((@ffi.load64((return_area) + 16)).reinterpret_as_uint64())
                        }
                        _ => panic()
                  }

                  Option::Some(lifted)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}

pub fn FutureRecipientsResult::subscribe(self : FutureRecipientsResult) -> @poll.Pollable {

      let FutureRecipientsResult(handle) = self
      let result : Int =  wasmImportMethodFutureRecipientsResultSubscribe(handle);
      return @poll.Pollable::Pollable(result)

}

pub fn FutureRecipientsResult::get(self : FutureRecipientsResult) -> Array[String]? {

      let FutureRecipientsResult(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodFutureRecipientsResultGet(handle, return_area);

      let lifted : Array[String]? = match @ffi.load8_u((return_area) + 0) {
            0 => Option::None
            1 => {

                  let array : Array[String] = [];
                  for index = 0; index < (@ffi.load32((return_area) + 8)); index = index + 1 {
                        let base3 = (@ffi.load32((return_area) + 4)) + (index * 8)

                        ignore(@ffi.load32((base3) + 4))
                        let result = @ffi.ptr2str(@ffi.load32((base3) + 0))

                        array.push(result)
                  }
                  @ffi.free(@ffi.load32((return_area) + 4))

                  Option::Some(array)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn Api::api(location : @types.Uri) -> Api {

      let result : Int =  wasmImportConstructorApi(@ffi.str2ptr((location).value), (location).value.iter().count());
      ignore((location).value)
      return Api::Api(result)

}

pub fn Api::blocking_add(self : Api, c : @api.Connection, value : String) -> Result[Unit, String] {

      let Api(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodApiBlockingAdd(handle, ((c).id).reinterpret_as_int64(), @ffi.str2ptr(value), value.iter().count(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  ignore(@ffi.load32((return_area) + 8))
                  let result = @ffi.ptr2str(@ffi.load32((return_area) + 4))

                  Result::Err(result)
            }
            _ => panic()
      }
      ignore(value)
      @ffi.free(return_area)
      return lifted

}

pub fn Api::add(self : Api, c : @api.Connection, value : String) -> FutureAddResult {

      let Api(handle) = self
      let result : Int =  wasmImportMethodApiAdd(handle, ((c).id).reinterpret_as_int64(), @ffi.str2ptr(value), value.iter().count());
      ignore(value)
      return FutureAddResult::FutureAddResult(result)

}

pub fn Api::blocking_archive(self : Api) -> Unit {

      let Api(handle) = self
      wasmImportMethodApiBlockingArchive(handle);

}

pub fn Api::archive(self : Api) -> Unit {

      let Api(handle) = self
      wasmImportMethodApiArchive(handle);

}

pub fn Api::blocking_connect(self : Api, email : String) -> (@api.Connection, Array[String]) {

      let Api(handle) = self
      let return_area = @ffi.malloc(16)
      wasmImportMethodApiBlockingConnect(handle, @ffi.str2ptr(email), email.iter().count(), return_area);

      let array : Array[String] = [];
      for index = 0; index < (@ffi.load32((return_area) + 12)); index = index + 1 {
            let base = (@ffi.load32((return_area) + 8)) + (index * 8)

            ignore(@ffi.load32((base) + 4))
            let result = @ffi.ptr2str(@ffi.load32((base) + 0))

            array.push(result)
      }
      @ffi.free(@ffi.load32((return_area) + 8))
      ignore(email)
      @ffi.free(return_area)
      return (@api.Connection::{id : (@ffi.load64((return_area) + 0)).reinterpret_as_uint64()}, array)

}

pub fn Api::connect(self : Api, email : String) -> FutureConnectResult {

      let Api(handle) = self
      let result : Int =  wasmImportMethodApiConnect(handle, @ffi.str2ptr(email), email.iter().count());
      ignore(email)
      return FutureConnectResult::FutureConnectResult(result)

}

pub fn Api::blocking_connected_editors(self : Api) -> Array[String] {

      let Api(handle) = self
      let return_area = @ffi.malloc(8)
      wasmImportMethodApiBlockingConnectedEditors(handle, return_area);

      let array : Array[String] = [];
      for index = 0; index < (@ffi.load32((return_area) + 4)); index = index + 1 {
            let base = (@ffi.load32((return_area) + 0)) + (index * 8)

            ignore(@ffi.load32((base) + 4))
            let result = @ffi.ptr2str(@ffi.load32((base) + 0))

            array.push(result)
      }
      @ffi.free(@ffi.load32((return_area) + 0))
      @ffi.free(return_area)
      return array

}

pub fn Api::connected_editors(self : Api) -> FutureConnectedEditorsResult {

      let Api(handle) = self
      let result : Int =  wasmImportMethodApiConnectedEditors(handle);
      return FutureConnectedEditorsResult::FutureConnectedEditorsResult(result)

}

pub fn Api::blocking_delete(self : Api, c : @api.Connection, value : String) -> Result[Unit, String] {

      let Api(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodApiBlockingDelete(handle, ((c).id).reinterpret_as_int64(), @ffi.str2ptr(value), value.iter().count(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  ignore(@ffi.load32((return_area) + 8))
                  let result = @ffi.ptr2str(@ffi.load32((return_area) + 4))

                  Result::Err(result)
            }
            _ => panic()
      }
      ignore(value)
      @ffi.free(return_area)
      return lifted

}

pub fn Api::delete(self : Api, c : @api.Connection, value : String) -> FutureDeleteResult {

      let Api(handle) = self
      let result : Int =  wasmImportMethodApiDelete(handle, ((c).id).reinterpret_as_int64(), @ffi.str2ptr(value), value.iter().count());
      ignore(value)
      return FutureDeleteResult::FutureDeleteResult(result)

}

pub fn Api::blocking_disconnect(self : Api, c : @api.Connection) -> Result[Unit, String] {

      let Api(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodApiBlockingDisconnect(handle, ((c).id).reinterpret_as_int64(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  ignore(@ffi.load32((return_area) + 8))
                  let result = @ffi.ptr2str(@ffi.load32((return_area) + 4))

                  Result::Err(result)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn Api::disconnect(self : Api, c : @api.Connection) -> FutureDisconnectResult {

      let Api(handle) = self
      let result : Int =  wasmImportMethodApiDisconnect(handle, ((c).id).reinterpret_as_int64());
      return FutureDisconnectResult::FutureDisconnectResult(result)

}

pub fn Api::blocking_get(self : Api) -> Array[String] {

      let Api(handle) = self
      let return_area = @ffi.malloc(8)
      wasmImportMethodApiBlockingGet(handle, return_area);

      let array : Array[String] = [];
      for index = 0; index < (@ffi.load32((return_area) + 4)); index = index + 1 {
            let base = (@ffi.load32((return_area) + 0)) + (index * 8)

            ignore(@ffi.load32((base) + 4))
            let result = @ffi.ptr2str(@ffi.load32((base) + 0))

            array.push(result)
      }
      @ffi.free(@ffi.load32((return_area) + 0))
      @ffi.free(return_area)
      return array

}

pub fn Api::get(self : Api) -> FutureGetResult {

      let Api(handle) = self
      let result : Int =  wasmImportMethodApiGet(handle);
      return FutureGetResult::FutureGetResult(result)

}

pub fn Api::blocking_insert(self : Api, c : @api.Connection, after : String, value : String) -> Result[Unit, String] {

      let Api(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodApiBlockingInsert(handle, ((c).id).reinterpret_as_int64(), @ffi.str2ptr(after), after.iter().count(), @ffi.str2ptr(value), value.iter().count(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  ignore(@ffi.load32((return_area) + 8))
                  let result = @ffi.ptr2str(@ffi.load32((return_area) + 4))

                  Result::Err(result)
            }
            _ => panic()
      }
      ignore(after)
      ignore(value)
      @ffi.free(return_area)
      return lifted

}

pub fn Api::insert(self : Api, c : @api.Connection, after : String, value : String) -> FutureInsertResult {

      let Api(handle) = self
      let result : Int =  wasmImportMethodApiInsert(handle, ((c).id).reinterpret_as_int64(), @ffi.str2ptr(after), after.iter().count(), @ffi.str2ptr(value), value.iter().count());
      ignore(after)
      ignore(value)
      return FutureInsertResult::FutureInsertResult(result)

}

pub fn Api::blocking_is_archived(self : Api) -> Bool {

      let Api(handle) = self
      let result : Int =  wasmImportMethodApiBlockingIsArchived(handle);
      return (result != 0)

}

pub fn Api::is_archived(self : Api) -> FutureIsArchivedResult {

      let Api(handle) = self
      let result : Int =  wasmImportMethodApiIsArchived(handle);
      return FutureIsArchivedResult::FutureIsArchivedResult(result)

}

pub fn Api::blocking_poll(self : Api, c : @api.Connection) -> Result[Array[@api.Change], String] {

      let Api(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodApiBlockingPoll(handle, ((c).id).reinterpret_as_int64(), return_area);

      let lifted14 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  let array : Array[@api.Change] = [];
                  for index = 0; index < (@ffi.load32((return_area) + 8)); index = index + 1 {
                        let base1 = (@ffi.load32((return_area) + 4)) + (index * 20)

                        let lifted = match (@ffi.load8_u((base1) + 0)) {
                              0 => {

                                    ignore(@ffi.load32((base1) + 8))
                                    let result = @ffi.ptr2str(@ffi.load32((base1) + 4))

                                    @api.Change::Added(result)
                              }
                              1 => {

                                    ignore(@ffi.load32((base1) + 8))
                                    let result6 = @ffi.ptr2str(@ffi.load32((base1) + 4))

                                    @api.Change::Deleted(result6)
                              }
                              2 => {

                                    ignore(@ffi.load32((base1) + 8))
                                    let result9 = @ffi.ptr2str(@ffi.load32((base1) + 4))

                                    ignore(@ffi.load32((base1) + 16))
                                    let result10 = @ffi.ptr2str(@ffi.load32((base1) + 12))

                                    @api.Change::Inserted(@api.InsertParams::{after : result9, value : result10})
                              }
                              _ => panic()
                        }

                        array.push(lifted)
                  }
                  @ffi.free(@ffi.load32((return_area) + 4))

                  Result::Ok(array)
            }
            1 => {

                  ignore(@ffi.load32((return_area) + 8))
                  let result13 = @ffi.ptr2str(@ffi.load32((return_area) + 4))

                  Result::Err(result13)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted14

}

pub fn Api::poll(self : Api, c : @api.Connection) -> FuturePollResult {

      let Api(handle) = self
      let result : Int =  wasmImportMethodApiPoll(handle, ((c).id).reinterpret_as_int64());
      return FuturePollResult::FuturePollResult(result)

}

pub fn EmailQuery::email_query(location : @types.Uri) -> EmailQuery {

      let result : Int =  wasmImportConstructorEmailQuery(@ffi.str2ptr((location).value), (location).value.iter().count());
      ignore((location).value)
      return EmailQuery::EmailQuery(result)

}

pub fn EmailQuery::blocking_deadline(self : EmailQuery) -> UInt64? {

      let EmailQuery(handle) = self
      let return_area = @ffi.malloc(16)
      wasmImportMethodEmailQueryBlockingDeadline(handle, return_area);

      let lifted : UInt64? = match @ffi.load8_u((return_area) + 0) {
            0 => Option::None
            1 => {

                  Option::Some((@ffi.load64((return_area) + 8)).reinterpret_as_uint64())
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn EmailQuery::deadline(self : EmailQuery) -> FutureDeadlineResult {

      let EmailQuery(handle) = self
      let result : Int =  wasmImportMethodEmailQueryDeadline(handle);
      return FutureDeadlineResult::FutureDeadlineResult(result)

}

pub fn EmailQuery::blocking_recipients(self : EmailQuery) -> Array[String] {

      let EmailQuery(handle) = self
      let return_area = @ffi.malloc(8)
      wasmImportMethodEmailQueryBlockingRecipients(handle, return_area);

      let array : Array[String] = [];
      for index = 0; index < (@ffi.load32((return_area) + 4)); index = index + 1 {
            let base = (@ffi.load32((return_area) + 0)) + (index * 8)

            ignore(@ffi.load32((base) + 4))
            let result = @ffi.ptr2str(@ffi.load32((base) + 0))

            array.push(result)
      }
      @ffi.free(@ffi.load32((return_area) + 0))
      @ffi.free(return_area)
      return array

}

pub fn EmailQuery::recipients(self : EmailQuery) -> FutureRecipientsResult {

      let EmailQuery(handle) = self
      let result : Int =  wasmImportMethodEmailQueryRecipients(handle);
      return FutureRecipientsResult::FutureRecipientsResult(result)

}

