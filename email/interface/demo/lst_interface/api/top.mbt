// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!

pub(all) struct Connection {
      id : UInt64
} derive()

pub(all) struct InsertParams {
      after : String; value : String
} derive()

pub(all) enum Change {
      Added(String)
      Deleted(String)
      Inserted(InsertParams)
} derive()

pub fn add(c : Connection, value : String) -> Result[Unit, String] {

      let return_area = @ffi.malloc(12)
      wasmImportAdd(((c).id).reinterpret_as_int64(), @ffi.str2ptr(value), value.iter().count(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  ignore(@ffi.load32((return_area) + 8))
                  let result = @ffi.ptr2str(@ffi.load32((return_area) + 4))

                  Result::Err(result)
            }
            _ => panic()
      }
      ignore(value)
      @ffi.free(return_area)
      return lifted

}

pub fn archive() -> Unit {

      wasmImportArchive();

}

pub fn connect(email : String) -> (Connection, Array[String]) {

      let return_area = @ffi.malloc(16)
      wasmImportConnect(@ffi.str2ptr(email), email.iter().count(), return_area);

      let array : Array[String] = [];
      for index = 0; index < (@ffi.load32((return_area) + 12)); index = index + 1 {
            let base = (@ffi.load32((return_area) + 8)) + (index * 8)

            ignore(@ffi.load32((base) + 4))
            let result = @ffi.ptr2str(@ffi.load32((base) + 0))

            array.push(result)
      }
      @ffi.free(@ffi.load32((return_area) + 8))
      ignore(email)
      @ffi.free(return_area)
      return (Connection::{id : (@ffi.load64((return_area) + 0)).reinterpret_as_uint64()}, array)

}

pub fn connected_editors() -> Array[String] {

      let return_area = @ffi.malloc(8)
      wasmImportConnectedEditors(return_area);

      let array : Array[String] = [];
      for index = 0; index < (@ffi.load32((return_area) + 4)); index = index + 1 {
            let base = (@ffi.load32((return_area) + 0)) + (index * 8)

            ignore(@ffi.load32((base) + 4))
            let result = @ffi.ptr2str(@ffi.load32((base) + 0))

            array.push(result)
      }
      @ffi.free(@ffi.load32((return_area) + 0))
      @ffi.free(return_area)
      return array

}

pub fn delete(c : Connection, value : String) -> Result[Unit, String] {

      let return_area = @ffi.malloc(12)
      wasmImportDelete(((c).id).reinterpret_as_int64(), @ffi.str2ptr(value), value.iter().count(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  ignore(@ffi.load32((return_area) + 8))
                  let result = @ffi.ptr2str(@ffi.load32((return_area) + 4))

                  Result::Err(result)
            }
            _ => panic()
      }
      ignore(value)
      @ffi.free(return_area)
      return lifted

}

pub fn disconnect(c : Connection) -> Result[Unit, String] {

      let return_area = @ffi.malloc(12)
      wasmImportDisconnect(((c).id).reinterpret_as_int64(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  ignore(@ffi.load32((return_area) + 8))
                  let result = @ffi.ptr2str(@ffi.load32((return_area) + 4))

                  Result::Err(result)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn get() -> Array[String] {

      let return_area = @ffi.malloc(8)
      wasmImportGet(return_area);

      let array : Array[String] = [];
      for index = 0; index < (@ffi.load32((return_area) + 4)); index = index + 1 {
            let base = (@ffi.load32((return_area) + 0)) + (index * 8)

            ignore(@ffi.load32((base) + 4))
            let result = @ffi.ptr2str(@ffi.load32((base) + 0))

            array.push(result)
      }
      @ffi.free(@ffi.load32((return_area) + 0))
      @ffi.free(return_area)
      return array

}

pub fn insert(c : Connection, after : String, value : String) -> Result[Unit, String] {

      let return_area = @ffi.malloc(12)
      wasmImportInsert(((c).id).reinterpret_as_int64(), @ffi.str2ptr(after), after.iter().count(), @ffi.str2ptr(value), value.iter().count(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  ignore(@ffi.load32((return_area) + 8))
                  let result = @ffi.ptr2str(@ffi.load32((return_area) + 4))

                  Result::Err(result)
            }
            _ => panic()
      }
      ignore(after)
      ignore(value)
      @ffi.free(return_area)
      return lifted

}

pub fn is_archived() -> Bool {

      let result : Int =  wasmImportIsArchived();
      return (result != 0)

}

pub fn poll(c : Connection) -> Result[Array[Change], String] {

      let return_area = @ffi.malloc(12)
      wasmImportPoll(((c).id).reinterpret_as_int64(), return_area);

      let lifted14 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  let array : Array[Change] = [];
                  for index = 0; index < (@ffi.load32((return_area) + 8)); index = index + 1 {
                        let base1 = (@ffi.load32((return_area) + 4)) + (index * 20)

                        let lifted = match (@ffi.load8_u((base1) + 0)) {
                              0 => {

                                    ignore(@ffi.load32((base1) + 8))
                                    let result = @ffi.ptr2str(@ffi.load32((base1) + 4))

                                    Change::Added(result)
                              }
                              1 => {

                                    ignore(@ffi.load32((base1) + 8))
                                    let result6 = @ffi.ptr2str(@ffi.load32((base1) + 4))

                                    Change::Deleted(result6)
                              }
                              2 => {

                                    ignore(@ffi.load32((base1) + 8))
                                    let result9 = @ffi.ptr2str(@ffi.load32((base1) + 4))

                                    ignore(@ffi.load32((base1) + 16))
                                    let result10 = @ffi.ptr2str(@ffi.load32((base1) + 12))

                                    Change::Inserted(InsertParams::{after : result9, value : result10})
                              }
                              _ => panic()
                        }

                        array.push(lifted)
                  }
                  @ffi.free(@ffi.load32((return_area) + 4))

                  Result::Ok(array)
            }
            1 => {

                  ignore(@ffi.load32((return_area) + 8))
                  let result13 = @ffi.ptr2str(@ffi.load32((return_area) + 4))

                  Result::Err(result13)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted14

}

