// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!

pub fn wasmExportAdd(p0 : Int64, p1 : Int, p2 : Int) -> Int {

      ignore(p2)
      let result = @ffi.ptr2str(p1)

      let (result0) : (Result[Unit, String]) = @api.add(@api.Connection::{id : (p0).reinterpret_as_uint64()}, result);

      match result0 {
            Ok(_payload) => {
                  @ffi.store8((return_area) + 0, (0))

                  ()
            }
            Err(payload3) => {
                  @ffi.store8((return_area) + 0, (1))
                  @ffi.store32((return_area) + 8, payload3.iter().count())
                  @ffi.store32((return_area) + 4, @ffi.str2ptr(payload3))

                  ()
            }
      }
      return return_area

}

pub fn wasmExportAddPostReturn(p0 : Int) -> Unit {

      match (@ffi.load8_u((p0) + 0)) {
            0 => ()
            1 => {
                  @ffi.free(@ffi.load32((p0) + 4))

            }
            _ => panic()
      }

}

pub fn wasmExportDelete(p0 : Int64, p1 : Int, p2 : Int) -> Int {

      ignore(p2)
      let result = @ffi.ptr2str(p1)

      let (result0) : (Result[Unit, String]) = @api.delete(@api.Connection::{id : (p0).reinterpret_as_uint64()}, result);

      match result0 {
            Ok(_payload) => {
                  @ffi.store8((return_area) + 0, (0))

                  ()
            }
            Err(payload3) => {
                  @ffi.store8((return_area) + 0, (1))
                  @ffi.store32((return_area) + 8, payload3.iter().count())
                  @ffi.store32((return_area) + 4, @ffi.str2ptr(payload3))

                  ()
            }
      }
      return return_area

}

pub fn wasmExportDeletePostReturn(p0 : Int) -> Unit {

      match (@ffi.load8_u((p0) + 0)) {
            0 => ()
            1 => {
                  @ffi.free(@ffi.load32((p0) + 4))

            }
            _ => panic()
      }

}

pub fn wasmExportInsert(p0 : Int64, p1 : Int, p2 : Int, p3 : Int, p4 : Int) -> Int {

      ignore(p2)
      let result = @ffi.ptr2str(p1)

      ignore(p4)
      let result0 = @ffi.ptr2str(p3)

      let (result1) : (Result[Unit, String]) = @api.insert(@api.Connection::{id : (p0).reinterpret_as_uint64()}, result, result0);

      match result1 {
            Ok(_payload) => {
                  @ffi.store8((return_area) + 0, (0))

                  ()
            }
            Err(payload4) => {
                  @ffi.store8((return_area) + 0, (1))
                  @ffi.store32((return_area) + 8, payload4.iter().count())
                  @ffi.store32((return_area) + 4, @ffi.str2ptr(payload4))

                  ()
            }
      }
      return return_area

}

pub fn wasmExportInsertPostReturn(p0 : Int) -> Unit {

      match (@ffi.load8_u((p0) + 0)) {
            0 => ()
            1 => {
                  @ffi.free(@ffi.load32((p0) + 4))

            }
            _ => panic()
      }

}

pub fn wasmExportGet() -> Int {

      let (result) : (Array[String]) = @api.get();

      let address = @ffi.malloc((result).length() * 8);
      for index = 0; index < (result).length(); index = index + 1 {
            let element : String = (result)[(index)]
            let base = address + (index * 8);
            @ffi.store32((base) + 4, element.iter().count())
            @ffi.store32((base) + 0, @ffi.str2ptr(element))

      }
      @ffi.store32((return_area) + 4, (result).length())
      @ffi.store32((return_area) + 0, address)
      return return_area

}

pub fn wasmExportGetPostReturn(p0 : Int) -> Unit {

      for index = 0; index < (@ffi.load32((p0) + 4)); index = index + 1 {
            let base = (@ffi.load32((p0) + 0)) + (index * 8)
            @ffi.free(@ffi.load32((base) + 0))

      }
      @ffi.free(@ffi.load32((p0) + 0))

}

pub fn wasmExportPoll(p0 : Int64) -> Int {

      let (result) : (Result[Array[@api.Change], String]) = @api.poll(@api.Connection::{id : (p0).reinterpret_as_uint64()});

      match result {
            Ok(payload) => {
                  @ffi.store8((return_area) + 0, (0))

                  let address = @ffi.malloc((payload).length() * 20);
                  for index = 0; index < (payload).length(); index = index + 1 {
                        let element0 : @api.Change = (payload)[(index)]
                        let base1 = address + (index * 20);

                        match element0 {
                              Added(payload4) => {
                                    @ffi.store8((base1) + 0, (0))
                                    @ffi.store32((base1) + 8, payload4.iter().count())
                                    @ffi.store32((base1) + 4, @ffi.str2ptr(payload4))

                                    ()
                              }
                              Deleted(payload7) => {
                                    @ffi.store8((base1) + 0, (1))
                                    @ffi.store32((base1) + 8, payload7.iter().count())
                                    @ffi.store32((base1) + 4, @ffi.str2ptr(payload7))

                                    ()
                              }
                              Inserted(payload10) => {
                                    @ffi.store8((base1) + 0, (2))
                                    @ffi.store32((base1) + 8, (payload10).after.iter().count())
                                    @ffi.store32((base1) + 4, @ffi.str2ptr((payload10).after))
                                    @ffi.store32((base1) + 16, (payload10).value.iter().count())
                                    @ffi.store32((base1) + 12, @ffi.str2ptr((payload10).value))

                                    ()
                              }
                        }

                  }
                  @ffi.store32((return_area) + 8, (payload).length())
                  @ffi.store32((return_area) + 4, address)

                  ()
            }
            Err(payload13) => {
                  @ffi.store8((return_area) + 0, (1))
                  @ffi.store32((return_area) + 8, payload13.iter().count())
                  @ffi.store32((return_area) + 4, @ffi.str2ptr(payload13))

                  ()
            }
      }
      return return_area

}

pub fn wasmExportPollPostReturn(p0 : Int) -> Unit {

      match (@ffi.load8_u((p0) + 0)) {
            0 => {

                  for index = 0; index < (@ffi.load32((p0) + 8)); index = index + 1 {
                        let base1 = (@ffi.load32((p0) + 4)) + (index * 20)

                        match (@ffi.load8_u((base1) + 0)) {
                              0 => {
                                    @ffi.free(@ffi.load32((base1) + 4))

                              }
                              1 => {
                                    @ffi.free(@ffi.load32((base1) + 4))

                              }
                              2 => {
                                    @ffi.free(@ffi.load32((base1) + 4))
                                    @ffi.free(@ffi.load32((base1) + 12))

                              }
                              _ => panic()
                        }

                  }
                  @ffi.free(@ffi.load32((p0) + 4))

            }
            1 => {
                  @ffi.free(@ffi.load32((p0) + 4))

            }
            _ => panic()
      }

}

pub fn wasmExportConnect(p0 : Int, p1 : Int) -> Int {

      ignore(p1)
      let result = @ffi.ptr2str(p0)

      let (result0) : ((@api.Connection, Array[String])) = @api.connect(result);
      @ffi.store64((return_area) + 0, (((result0).0).id).reinterpret_as_int64())

      let address = @ffi.malloc(((result0).1).length() * 8);
      for index = 0; index < ((result0).1).length(); index = index + 1 {
            let element : String = ((result0).1)[(index)]
            let base = address + (index * 8);
            @ffi.store32((base) + 4, element.iter().count())
            @ffi.store32((base) + 0, @ffi.str2ptr(element))

      }
      @ffi.store32((return_area) + 12, ((result0).1).length())
      @ffi.store32((return_area) + 8, address)
      return return_area

}

pub fn wasmExportConnectPostReturn(p0 : Int) -> Unit {

      for index = 0; index < (@ffi.load32((p0) + 12)); index = index + 1 {
            let base = (@ffi.load32((p0) + 8)) + (index * 8)
            @ffi.free(@ffi.load32((base) + 0))

      }
      @ffi.free(@ffi.load32((p0) + 8))

}

pub fn wasmExportDisconnect(p0 : Int64) -> Int {

      let (result) : (Result[Unit, String]) = @api.disconnect(@api.Connection::{id : (p0).reinterpret_as_uint64()});

      match result {
            Ok(_payload) => {
                  @ffi.store8((return_area) + 0, (0))

                  ()
            }
            Err(payload2) => {
                  @ffi.store8((return_area) + 0, (1))
                  @ffi.store32((return_area) + 8, payload2.iter().count())
                  @ffi.store32((return_area) + 4, @ffi.str2ptr(payload2))

                  ()
            }
      }
      return return_area

}

pub fn wasmExportDisconnectPostReturn(p0 : Int) -> Unit {

      match (@ffi.load8_u((p0) + 0)) {
            0 => ()
            1 => {
                  @ffi.free(@ffi.load32((p0) + 4))

            }
            _ => panic()
      }

}

pub fn wasmExportConnectedEditors() -> Int {

      let (result) : (Array[String]) = @api.connected_editors();

      let address = @ffi.malloc((result).length() * 8);
      for index = 0; index < (result).length(); index = index + 1 {
            let element : String = (result)[(index)]
            let base = address + (index * 8);
            @ffi.store32((base) + 4, element.iter().count())
            @ffi.store32((base) + 0, @ffi.str2ptr(element))

      }
      @ffi.store32((return_area) + 4, (result).length())
      @ffi.store32((return_area) + 0, address)
      return return_area

}

pub fn wasmExportConnectedEditorsPostReturn(p0 : Int) -> Unit {

      for index = 0; index < (@ffi.load32((p0) + 4)); index = index + 1 {
            let base = (@ffi.load32((p0) + 0)) + (index * 8)
            @ffi.free(@ffi.load32((base) + 0))

      }
      @ffi.free(@ffi.load32((p0) + 0))

}

pub fn wasmExportArchive() -> Unit {

      let _ = @api.archive();

}

pub fn wasmExportIsArchived() -> Int {

      let (result) : (Bool) = @api.is_archived();
      return (if result { 1 } else { 0 })

}

