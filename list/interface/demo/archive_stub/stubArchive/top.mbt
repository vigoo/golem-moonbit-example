// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!

pub(all) type FutureGetAllResult Int derive(Show)

/// Drops a resource handle.
pub fn FutureGetAllResult::drop(self : FutureGetAllResult) -> Unit {
      let FutureGetAllResult(resource) = self
      wasmImportResourceDropFutureGetAllResult(resource)
}

pub(all) type Api Int derive(Show)

/// Drops a resource handle.
pub fn Api::drop(self : Api) -> Unit {
      let Api(resource) = self
      wasmImportResourceDropApi(resource)
}

pub fn FutureGetAllResult::subscribe(self : FutureGetAllResult) -> @poll.Pollable {

      let FutureGetAllResult(handle) = self
      let result : Int =  wasmImportMethodFutureGetAllResultSubscribe(handle);
      return @poll.Pollable::Pollable(result)

}

pub fn FutureGetAllResult::get(self : FutureGetAllResult) -> Array[@api.ArchivedList]? {

      let FutureGetAllResult(handle) = self
      let return_area = @ffi.malloc(12)
      wasmImportMethodFutureGetAllResultGet(handle, return_area);

      let lifted : Array[@api.ArchivedList]? = match @ffi.load8_u((return_area) + 0) {
            0 => Option::None
            1 => {

                  let array7 : Array[@api.ArchivedList] = [];
                  for index8 = 0; index8 < (@ffi.load32((return_area) + 8)); index8 = index8 + 1 {
                        let base3 = (@ffi.load32((return_area) + 4)) + (index8 * 16)

                        ignore(@ffi.load32((base3) + 4))
                        let result = @ffi.ptr2str(@ffi.load32((base3) + 0))

                        let array : Array[String] = [];
                        for index = 0; index < (@ffi.load32((base3) + 12)); index = index + 1 {
                              let base5 = (@ffi.load32((base3) + 8)) + (index * 8)

                              ignore(@ffi.load32((base5) + 4))
                              let result6 = @ffi.ptr2str(@ffi.load32((base5) + 0))

                              array.push(result6)
                        }
                        @ffi.free(@ffi.load32((base3) + 8))

                        array7.push(@api.ArchivedList::{name : result, items : array})
                  }
                  @ffi.free(@ffi.load32((return_area) + 4))

                  Option::Some(array7)
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn Api::api(location : @types.Uri) -> Api {

      let result : Int =  wasmImportConstructorApi(@ffi.str2ptr((location).value), (location).value.iter().count());
      ignore((location).value)
      return Api::Api(result)

}

pub fn Api::blocking_get_all(self : Api) -> Array[@api.ArchivedList] {

      let Api(handle) = self
      let return_area = @ffi.malloc(8)
      wasmImportMethodApiBlockingGetAll(handle, return_area);

      let array3 : Array[@api.ArchivedList] = [];
      for index4 = 0; index4 < (@ffi.load32((return_area) + 4)); index4 = index4 + 1 {
            let base = (@ffi.load32((return_area) + 0)) + (index4 * 16)

            ignore(@ffi.load32((base) + 4))
            let result = @ffi.ptr2str(@ffi.load32((base) + 0))

            let array : Array[String] = [];
            for index = 0; index < (@ffi.load32((base) + 12)); index = index + 1 {
                  let base1 = (@ffi.load32((base) + 8)) + (index * 8)

                  ignore(@ffi.load32((base1) + 4))
                  let result2 = @ffi.ptr2str(@ffi.load32((base1) + 0))

                  array.push(result2)
            }
            @ffi.free(@ffi.load32((base) + 8))

            array3.push(@api.ArchivedList::{name : result, items : array})
      }
      @ffi.free(@ffi.load32((return_area) + 0))
      @ffi.free(return_area)
      return array3

}

pub fn Api::get_all(self : Api) -> FutureGetAllResult {

      let Api(handle) = self
      let result : Int =  wasmImportMethodApiGetAll(handle);
      return FutureGetAllResult::FutureGetAllResult(result)

}

pub fn Api::blocking_store(self : Api, name : String, items : Array[String]) -> Unit {
      let cleanupList : Array[@ffi.Cleanup] = []
      let ignoreList : Array[&@ffi.Any] = []

      let Api(handle) = self

      let address = @ffi.malloc((items).length() * 8);
      for index = 0; index < (items).length(); index = index + 1 {
            let element : String = (items)[(index)]
            let base = address + (index * 8);
            @ffi.store32((base) + 4, element.iter().count())
            @ffi.store32((base) + 0, @ffi.str2ptr(element))
            ignoreList.push(element)

      }
      wasmImportMethodApiBlockingStore(handle, @ffi.str2ptr(name), name.iter().count(), address, (items).length());
      ignore(name)
      @ffi.free(address)

      cleanupList.each(fn(cleanup) {
            @ffi.free(cleanup.address);
      })
      ignore(ignoreList)

}

pub fn Api::store(self : Api, name : String, items : Array[String]) -> Unit {
      let cleanupList : Array[@ffi.Cleanup] = []
      let ignoreList : Array[&@ffi.Any] = []

      let Api(handle) = self

      let address = @ffi.malloc((items).length() * 8);
      for index = 0; index < (items).length(); index = index + 1 {
            let element : String = (items)[(index)]
            let base = address + (index * 8);
            @ffi.store32((base) + 4, element.iter().count())
            @ffi.store32((base) + 0, @ffi.str2ptr(element))
            ignoreList.push(element)

      }
      wasmImportMethodApiStore(handle, @ffi.str2ptr(name), name.iter().count(), address, (items).length());
      ignore(name)
      @ffi.free(address)

      cleanupList.each(fn(cleanup) {
            @ffi.free(cleanup.address);
      })
      ignore(ignoreList)

}

