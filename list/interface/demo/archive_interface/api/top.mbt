// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!

pub(all) struct ArchivedList {
      name : String; items : Array[String]
} derive(Show)

pub fn get_all() -> Array[ArchivedList] {

      let return_area = @ffi.malloc(8)
      wasmImportGetAll(return_area);

      let array3 : Array[ArchivedList] = [];
      for index4 = 0; index4 < (@ffi.load32((return_area) + 4)); index4 = index4 + 1 {
            let base = (@ffi.load32((return_area) + 0)) + (index4 * 16)

            ignore(@ffi.load32((base) + 4))
            let result = @ffi.ptr2str(@ffi.load32((base) + 0))

            let array : Array[String] = [];
            for index = 0; index < (@ffi.load32((base) + 12)); index = index + 1 {
                  let base1 = (@ffi.load32((base) + 8)) + (index * 8)

                  ignore(@ffi.load32((base1) + 4))
                  let result2 = @ffi.ptr2str(@ffi.load32((base1) + 0))

                  array.push(result2)
            }
            @ffi.free(@ffi.load32((base) + 8))

            array3.push(ArchivedList::{name : result, items : array})
      }
      @ffi.free(@ffi.load32((return_area) + 0))
      @ffi.free(return_area)
      return array3

}

pub fn store(name : String, items : Array[String]) -> Unit {
      let cleanupList : Array[@ffi.Cleanup] = []
      let ignoreList : Array[&@ffi.Any] = []

      let address = @ffi.malloc((items).length() * 8);
      for index = 0; index < (items).length(); index = index + 1 {
            let element : String = (items)[(index)]
            let base = address + (index * 8);
            @ffi.store32((base) + 4, element.iter().count())
            @ffi.store32((base) + 0, @ffi.str2ptr(element))
            ignoreList.push(element)

      }
      wasmImportStore(@ffi.str2ptr(name), name.iter().count(), address, (items).length());
      ignore(name)
      @ffi.free(address)

      cleanupList.each(fn(cleanup) {
            @ffi.free(cleanup.address);
      })
      ignore(ignoreList)

}

